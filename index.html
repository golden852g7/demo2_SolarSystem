<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>交互式太阳系 · three.js</title>
<style>
  html, body { height:100%; margin:0; background:#06070a; color:#e7eaee; font-family: ui-sans-serif, system-ui, -apple-system,"Segoe UI",Roboto,Helvetica,Arial;}
  #app { position: fixed; inset: 0; }
  canvas { display:block; }
  .ui { position: fixed; left:16px; right:16px; bottom:16px; display:flex; gap:12px; align-items:center; padding:12px 14px;
        background:rgba(8,10,14,.55); backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,.06); border-radius:14px; }
  .row { display:flex; gap:10px; align-items:center; flex:1; }
  .chip { font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.05); white-space:nowrap; }
  input[type=range]{width:260px; height:4px; -webkit-appearance:none; appearance:none; background:linear-gradient(90deg,#6ecbff,#c9f); border-radius:999px;}
  input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:#fff; box-shadow:0 0 0 4px rgba(255,255,255,.18); cursor:pointer;}
  button{ cursor:pointer; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:#e7eaee; padding:8px 12px; font-weight:600;}
  .title{ position:fixed; left:16px; top:16px; padding:8px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.08); background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03)); }
  .hint{ position:fixed; right:16px; top:16px; opacity:.7; font-size:12px; }
  .kudos{ position:fixed; right:16px; bottom:16px; opacity:.5; font-size:12px; }
  .planet-label{ position:absolute; transform:translate(-50%,-120%); padding:3px 6px; font-size:11px; border-radius:8px; background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.1); pointer-events:none;}
  .panel{ position:fixed; right:16px; bottom:96px; width:340px; max-width:46vw; padding:14px 16px; border-radius:14px; border:1px solid rgba(255,255,255,.08);
          background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03)); box-shadow: 0 10px 30px rgba(0,0,0,.35);}
  .panel h3{ margin:0 0 8px; font-size:16px; }
  .grid{ display:grid; grid-template-columns:1fr 1fr; gap:6px 10px; font-size:12px; opacity:.9;}
  .kbd{ font-family:ui-monospace,Menlo,Consolas,monospace; font-size:11px; padding:2px 6px; border:1px solid rgba(255,255,255,.15); border-bottom-width:2px; border-radius:6px; background:rgba(255,255,255,.06);}
  .help{ margin-top:10px; font-size:11px; opacity:.8; }
  .tests{ position:fixed; right:16px; top:52px; font-size:12px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.04);}
  .tests .ok{ color:#a7f3d0;} .tests .fail{ color:#fecaca;}
</style>

<!-- 仍使用在线 three.js；若要彻底离线，把这里换成本地 vendor 路径即可 -->
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.161.0/build/three.module.js" } }
</script>
</head>
<body>
  <div id="app"></div>
  <div class="title">交互式太阳系 <span class="sep">·</span> 点击行星自动取景，双击空白回全景</div>
  <div class="hint">拖拽旋转 · 滚轮缩放 · 右键平移 · 空格播放/暂停 · R 全景 · O 自动环绕 · [ / ] 倍速 · 1-8 选行星</div>

  <div class="ui">
    <div class="row">
      <span class="chip">时间速率 <span id="rateText">1.0×</span></span>
      <input id="rate" type="range" min="-8" max="8" step="0.1" value="1" />
      <button id="rateReset">复原</button>
      <button id="play">暂停</button>
      <span class="chip">跟拍 <span id="followName">无</span></span>
      <button id="reset">回全景</button>
      <button id="toggleOrbit">自动环绕：开</button>
      <button id="togglePost">后期：开</button>
      <span class="chip">质量拖影</span>
      <input id="trail" type="range" min="0.6" max="0.98" step="0.01" value="0.90" />
    </div>
  </div>
  <div class="kudos">渲染：three.js · 后期：UnrealBloom + Afterimage · 粒子：星空点云</div>

  <div class="panel" id="infoPanel" style="display:none">
    <h3 id="pTitle">—</h3>
    <div class="grid">
      <span>中文名</span><strong id="pZh">—</strong>
      <span>英文名</span><strong id="pEn">—</strong>
      <span>轨道半径</span><strong id="pOrbit">—</strong>
      <span>公转周期</span><strong id="pPeriod">—</strong>
      <span>行星半径</span><strong id="pRadius">—</strong>
      <span>备注</span><strong id="pNote">—</strong>
    </div>
    <div class="help">
      <span class="kbd">空格</span> 播放/暂停 · <span class="kbd">R</span> 全景 · <span class="kbd">O</span> 自动环绕 · <span class="kbd">[ / ]</span> 倍速 · <span class="kbd">1-8</span> 选行星
    </div>
  </div>

  <div class="tests" id="tests"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { AfterimagePass } from 'https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/AfterimagePass.js';

window.addEventListener('DOMContentLoaded', () => {
/* ---------- 基础 ---------- */
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2('#06070a', 0.00022);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2e6);
camera.position.set(0, 180, 420);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.minDistance = 20;
controls.maxDistance = 4000;

/* 拖拽/滚轮时临时关闭拖影，避免太阳拉尾 */
let wheelTimer = 0;
controls.addEventListener('start', () => { afterimagePass.enabled = false; });
controls.addEventListener('end',   () => { afterimagePass.enabled = true;  });
renderer.domElement.addEventListener('wheel', () => {
  afterimagePass.enabled = false;
  clearTimeout(wheelTimer);
  wheelTimer = setTimeout(()=> afterimagePass.enabled = true, 150);
}, { passive:true });

/* ---------- 纹理（本地相对路径） ---------- */
const loader = new THREE.TextureLoader();
const TX = (f) => `./assets/planets/${f}`;
const setTex = (tex) => { if(!tex) return tex; tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); tex.colorSpace = THREE.SRGBColorSpace; return tex; };

/* ---------- 星空 ---------- */
const stars = new THREE.BufferGeometry();
const starCount = 4500, pos = new Float32Array(starCount*3);
for (let i=0;i<starCount;i++){ const r=5000*Math.pow(Math.random(),0.35), th=Math.random()*Math.PI*2, ph=Math.acos(THREE.MathUtils.randFloatSpread(2));
  pos[i*3]=r*Math.sin(ph)*Math.cos(th); pos[i*3+1]=r*Math.sin(ph)*Math.sin(th); pos[i*3+2]=r*Math.cos(ph); }
stars.setAttribute('position', new THREE.BufferAttribute(pos,3));
scene.add(new THREE.Points(stars, new THREE.PointsMaterial({ color:0x9fb3ff, size:2.0, sizeAttenuation:true, transparent:true, opacity:0.6, depthWrite:false })));

/* ---------- 太阳 ---------- */
const sun = new THREE.Mesh(new THREE.SphereGeometry(22, 96, 96),
  new THREE.MeshBasicMaterial({ map:setTex(loader.load(TX('sun.jpg'))) }));
scene.add(sun);
scene.add(new THREE.Mesh(new THREE.SphereGeometry(40, 48, 48),
  new THREE.MeshBasicMaterial({ color:0xffb347, transparent:true, opacity:0.16, blending:THREE.AdditiveBlending, depthWrite:false })));

scene.add(new THREE.AmbientLight(0xffffff, 0.18));
const sunLight = new THREE.PointLight(0xffffff, 2.1, 0, 2); scene.add(sunLight);

/* ---------- 行星 ---------- */
const AU = 100, VIS = 1.5;
const defs = [
  { key:'Mercury', zh:'水星', map:'mercury.jpg', size:2.44*VIS, orbit:0.39*AU, period:88,  bump:'mercurybump.jpg', bumpScale:0.02, note:'昼夜温差极大' },
  { key:'Venus',   zh:'金星', map:'venus.jpg',   size:6.05*VIS, orbit:0.72*AU, period:225, note:'厚大气与温室效应' },
  { key:'Earth',   zh:'地球', map:'earth_atmos_2048.jpg', size:6.37*VIS, orbit:1.00*AU, period:365,
    spec:'earth_specular_2048.jpg', normal:'earth_normal_2048.jpg', clouds:'earth_clouds_1024.png', hasMoon:true, note:'蓝色星球' },
  { key:'Mars',    zh:'火星', map:'mars_1k_color.jpg',    size:3.39*VIS, orbit:1.52*AU, period:687, bump:'mars_1k_topology.jpg', bumpScale:0.04, note:'铁锈色表面' },
  { key:'Jupiter', zh:'木星', map:'jupiter.jpg', size:(69.9/5)*VIS, orbit:5.20*AU, period:4333, note:'气体巨行星' },
  { key:'Saturn',  zh:'土星', map:'saturn.jpg', size:(58.2/5)*VIS, orbit:9.54*AU, period:10759, hasRings:true, note:'标志性行星环' },
  { key:'Uranus',  zh:'天王星', map:'uranus.jpg', size:(25.4/5)*VIS, orbit:19.2*AU, period:30687, note:'自转轴接近躺平' },
  { key:'Neptune', zh:'海王星', map:'neptune.jpg', size:(24.6/5)*VIS, orbit:30.1*AU, period:60190, note:'最外侧巨行星' },
];
const planets = [];
const orbitMat = new THREE.LineBasicMaterial({ color:0x3a4a63, transparent:true, opacity:0.7 });

const glowSpriteMat = (()=>{ const c=document.createElement('canvas'); c.width=c.height=64; const ctx=c.getContext('2d');
  const g=ctx.createRadialGradient(32,32,0,32,32,32); g.addColorStop(0,'rgba(255,255,255,.95)'); g.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,64,64); const t=new THREE.CanvasTexture(c);
  return new THREE.SpriteMaterial({ map:t, blending:THREE.AdditiveBlending, transparent:true, depthWrite:false}); })();

function makePlanet(def){
  const seg = Math.min(128, Math.max(64, Math.floor(def.size*8)));
  const mat = new THREE.MeshStandardMaterial({
    map: setTex(loader.load(TX(def.map))),
    roughness: 0.9,
    metalness: 0.02,
    emissive: 0x141414,
    emissiveIntensity: 0.3
  });
  if (def.bump){ mat.bumpMap = setTex(loader.load(TX(def.bump))); mat.bumpScale = def.bumpScale||0.02; }
  // MeshStandardMaterial 没有 specularMap：把地球的这张图当作 roughnessMap 使用（可选）
  if (def.spec){ mat.roughnessMap = setTex(loader.load(TX(def.spec))); }
  if (def.normal){ mat.normalMap = setTex(loader.load(TX(def.normal))); }

  const mesh = new THREE.Mesh(new THREE.SphereGeometry(def.size, seg, seg), mat);
  scene.add(mesh);

  // 轨道圈
  const segments=256, og=new THREE.BufferGeometry(), arr=new Float32Array((segments+1)*3);
  for(let i=0;i<=segments;i++){ const a=i/segments*Math.PI*2; arr[i*3]=Math.cos(a)*def.orbit; arr[i*3+1]=0; arr[i*3+2]=Math.sin(a)*def.orbit; }
  og.setAttribute('position', new THREE.BufferAttribute(arr,3));
  scene.add(new THREE.Line(og, orbitMat));

  // 环
  if (def.hasRings){
    const ringTex=setTex(loader.load(TX('saturnring.png')));
    const rings=new THREE.Mesh(new THREE.RingGeometry(def.size*1.6, def.size*2.5, 128),
      new THREE.MeshStandardMaterial({ map:ringTex, alphaMap:ringTex, transparent:true, side:THREE.DoubleSide, roughness:1.0, metalness:0.0 }));
    rings.rotation.x=Math.PI/2.6; mesh.add(rings);
  }

  // 云层（地球）
  let clouds=null;
  if (def.clouds){
    const cTex=setTex(loader.load(TX(def.clouds)));
    clouds=new THREE.Mesh(new THREE.SphereGeometry(def.size*1.01, seg, seg),
      new THREE.MeshStandardMaterial({ map:cTex, transparent:true, opacity:0.9, depthWrite:false }));
    mesh.add(clouds);
  }

  // 月球（地球）
  let moon=null;
  if (def.hasMoon){
    moon=new THREE.Mesh(new THREE.SphereGeometry(1.9, 64, 64),
      new THREE.MeshStandardMaterial({ map:setTex(loader.load(TX('moon_1024.jpg'))), roughness:1.0, emissive:0x080808, emissiveIntensity:0.2 }));
    mesh.add(moon);
  }

  const spr=new THREE.Sprite(glowSpriteMat.clone()); const s=Math.max(6, def.size*1.25); spr.scale.set(s,s,1); mesh.add(spr);

  return { name:def.key, zh:def.zh, size:def.size, orbit:def.orbit, period:def.period, note:def.note, mesh, moon, clouds };
}
defs.forEach(d=>planets.push(makePlanet(d)));

/* ---------- 标签 ---------- */
const labelLayer=document.createElement('div'); Object.assign(labelLayer.style,{position:'fixed',inset:'0',pointerEvents:'none'}); document.body.appendChild(labelLayer);
const labels=new Map();
function getLabel(name){ if(!labels.has(name)){ const el=document.createElement('div'); el.className='planet-label'; el.textContent=name; labelLayer.appendChild(el); labels.set(name, el);} return labels.get(name); }

/* ---------- 后期（带安全回退） ---------- */
const composer=new EffectComposer(renderer);
const renderPass=new RenderPass(scene,camera); composer.addPass(renderPass);
const bloomPass=new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 0.85, 0.6, 0.0);
const afterimagePass=new AfterimagePass(0.90);
composer.addPass(bloomPass); composer.addPass(afterimagePass);

let useComposer = true;                       // 只声明一次
let usedComposerLastFrame = false;

const togglePostBtn = document.getElementById('togglePost');
togglePostBtn.addEventListener('click', ()=>{
  useComposer = !useComposer;
  togglePostBtn.textContent = '后期：' + (useComposer ? '开' : '关');
});

/* ---------- 交互 / 取景 ---------- */
const raycaster=new THREE.Raycaster(); const pointer=new THREE.Vector2();
let follow=null;
const toPointer=(ev)=>{ const r=renderer.domElement.getBoundingClientRect(); pointer.x=((ev.clientX-r.left)/r.width)*2-1; pointer.y=-((ev.clientY-r.top)/r.height)*2+1; };

function focusPlanet(p){
  const dir=p.mesh.position.clone().normalize();
  const side=new THREE.Vector3(0,1,0).cross(dir).normalize();
  const up=dir.clone().cross(side).normalize();
  const dist=Math.max(60, p.size*7 + 40), sideShift=Math.max(20, p.orbit*0.02);
  const camPos=p.mesh.position.clone().add(dir.multiplyScalar(dist)).add(side.multiplyScalar(sideShift)).add(up.multiplyScalar(p.size*0.6));
  camera.position.copy(camPos); controls.target.copy(p.mesh.position);
}

const followNameEl = document.getElementById('followName');
renderer.domElement.addEventListener('click', (ev)=>{
  toPointer(ev);
  raycaster.setFromCamera(pointer, camera);
  const hit = raycaster.intersectObjects(planets.map(p=>p.mesh), false)[0];
  if (hit){ follow = planets.find(p=>p.mesh===hit.object); followNameEl.textContent = follow.name; updateInfoPanel(); focusPlanet(follow); }
});
renderer.domElement.addEventListener('dblclick', (ev)=>{
  toPointer(ev);
  raycaster.setFromCamera(pointer, camera);
  const hit = raycaster.intersectObjects(planets.map(p=>p.mesh), false)[0];
  if (!hit){ doResetView(); }
});

/* ---------- 时间/控件 ---------- */
let desiredRate=1.0, paused=false, autoOrbit=true;
const rateEl = document.getElementById('rate');
const rateText = document.getElementById('rateText');
const playBtn = document.getElementById('play');
const resetBtn = document.getElementById('reset');
const toggleOrbitBtn = document.getElementById('toggleOrbit');
const trailSlider = document.getElementById('trail');
const rateResetBtn = document.getElementById('rateReset');

function refreshRateText(){
  const isNeg = desiredRate < 0;
  const disp = isNeg ? (1/(1+Math.abs(desiredRate))).toFixed(2)
                     : Math.abs(desiredRate).toFixed(1);
  rateText.textContent = `${disp}×` + (paused ? '（暂停）' : '');
}

function mappedRate(r){
  if (paused) return 0;
  // 正数按原速；负数映射为 (0,1) 的正数，不反向
  return r >= 0 ? r : 1 / (1 + Math.abs(r));
}


rateEl.addEventListener('input', ()=>{ desiredRate=parseFloat(rateEl.value); refreshRateText(); });
playBtn.addEventListener('click', ()=>{ paused=!paused; playBtn.textContent=paused?'播放':'暂停'; refreshRateText(); });
toggleOrbitBtn.addEventListener('click', ()=>{ autoOrbit=!autoOrbit; toggleOrbitBtn.textContent='自动环绕：'+(autoOrbit?'开':'关'); });
function doResetView(){ follow=null; followNameEl.textContent='无'; controls.target.set(0,0,0); camera.position.set(0,180,520); hideInfoPanel(); }
resetBtn.addEventListener('click', doResetView);
trailSlider.addEventListener('input', ()=>{ afterimagePass.uniforms['damp'].value=parseFloat(trailSlider.value); });
rateResetBtn.addEventListener('click', ()=>{ desiredRate=1.0; rateEl.value='1'; refreshRateText(); });

/* ---------- 快捷键：1-8 选行星 / 0 R 回全景 / 空格播放 / O 自动环绕 / [ ] 调速 ---------- */
function selectPlanetByIndex(i){ const p=planets[i]; if(!p) return; follow=p; followNameEl.textContent=p.name; updateInfoPanel(); focusPlanet(p); }
document.addEventListener('keydown', (e)=>{
  const tag = document.activeElement?.tagName;
  if (tag === 'INPUT' || tag === 'TEXTAREA') return;
  if (e.key >= '1' && e.key <= '8'){ selectPlanetByIndex(parseInt(e.key,10)-1); }
  else if (e.key==='0' || e.key==='r' || e.key==='R'){ doResetView(); }
  else if (e.key===' '){ e.preventDefault(); playBtn.click(); }
  else if (e.key==='o' || e.key==='O'){ toggleOrbitBtn.click(); }
  else if (e.key==='['){ rateEl.value = String(Math.max(parseFloat(rateEl.min), parseFloat(rateEl.value)-0.1)); rateEl.dispatchEvent(new Event('input')); }
  else if (e.key===']'){ rateEl.value = String(Math.min(parseFloat(rateEl.max), parseFloat(rateEl.value)+0.1)); rateEl.dispatchEvent(new Event('input')); }
});

/* ---------- 信息面板 ---------- */
const panel=document.getElementById('infoPanel');
const pTitle=document.getElementById('pTitle'), pZh=document.getElementById('pZh'), pEn=document.getElementById('pEn'),
      pOrbit=document.getElementById('pOrbit'), pPeriod=document.getElementById('pPeriod'),
      pRadius=document.getElementById('pRadius'), pNote=document.getElementById('pNote');
function updateInfoPanel(){
  if (!follow){ hideInfoPanel(); return; }
  panel.style.display='block';
  pTitle.textContent=`${follow.zh} · ${follow.name}`;
  pZh.textContent=follow.zh; pEn.textContent=follow.name;
  pOrbit.textContent=(follow.orbit/AU).toFixed(2)+' AU';
  pPeriod.textContent=follow.period+' 天';
  pRadius.textContent=follow.size.toFixed(2)+'（缩放）';
  pNote.textContent=follow.note||'—';
}
function hideInfoPanel(){ panel.style.display='none'; }

/* ---------- 动画 ---------- */
const clock=new THREE.Clock();
let tSim=0;

function updatePlanets(dt){
  const eff = mappedRate(desiredRate);
  const dtDays = eff * dt * 60;
  tSim += dtDays;

  for(const p of planets){
    const a = (tSim / p.period) * Math.PI * 2;
    p.mesh.position.set(Math.cos(a)*p.orbit, 0, Math.sin(a)*p.orbit);
    if (p.clouds) p.clouds.rotation.y += dt * 0.03 * Math.sign(eff||1);
    if (p.moon){
      const ma = (tSim / 27.3) * Math.PI * 2;
      p.moon.position.set(Math.cos(ma)*12, Math.sin(ma*0.2)*2, Math.sin(ma)*12);
    }
    const label = getLabel(p.name);
    const v = p.mesh.position.clone().project(camera);
    label.style.left = (v.x*0.5+0.5)*innerWidth + 'px';
    label.style.top  = (-v.y*0.5+0.5)*innerHeight + 'px';
    label.style.display = (v.z < 1) ? 'block' : 'none';
  }
  sunLight.position.set(0,0,0);
}

function updateCamera(dt){
  if (paused){ controls.update(); return; }
  if (follow){
    const target = follow.mesh.position;
    controls.target.lerp(target, 1 - Math.pow(0.0008, dt));
  } else if (autoOrbit) {
    const base = 0.2;
    const rad = THREE.MathUtils.degToRad(performance.now()*0.001 * base * 60);
    const R = 520, y = 160 + Math.sin(rad*0.7)*40, x = Math.cos(rad)*R, z = Math.sin(rad)*R;
    camera.position.lerp(new THREE.Vector3(x,y,z), 0.02);
    controls.target.lerp(new THREE.Vector3(0,0,0), 0.05);
  }
  controls.update();
}

function spin(dt){
  if (paused) return;
  const s = Math.sign(mappedRate(desiredRate)||1);
  sun.rotation.y += dt * 0.15 * s;
  for (const p of planets) p.mesh.rotation.y += dt * 0.5 * s;
}

/* 安全渲染：合成链失败时回退直渲染 */
function safeRender(){
  try{
    if (useComposer){ composer.render(); usedComposerLastFrame = true; }
    else { renderer.render(scene, camera); usedComposerLastFrame = false; }
  }catch(e){
    console.error('后期渲染失败，已回退直渲染：', e);
    useComposer = false;
    renderer.render(scene, camera);
    usedComposerLastFrame = false;
    togglePostBtn.textContent = '后期：关';
  }
}

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  updatePlanets(dt);
  updateCamera(dt);
  spin(dt);
  safeRender();
  _test.ticks++;
}
animate();

/* ---------- 适配 ---------- */
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); bloomPass.setSize(innerWidth, innerHeight); });

/* ---------- 测试 ---------- */
const tests = document.getElementById('tests');
const log=(ok,msg)=>{ const d=document.createElement('div'); d.className=ok?'ok':'fail'; d.textContent=(ok?'✔ ':'✖ ')+msg; tests.appendChild(d); (ok?console.info:console.error)(msg); };
const _test={ ticks:0 };
log(typeof THREE==='object','THREE 模块解析成功');
log(Array.isArray(defs)&&defs.length===8,'已创建 8 颗行星');
setTimeout(()=>log(_test.ticks>=30,'渲染循环运行中'),2000);
loader.load(TX('sun.jpg'),()=>log(true,'纹理加载成功（sun.jpg）'),undefined,()=>log(false,'纹理加载失败（sun.jpg）'));
setTimeout(()=>{ const before=rateEl.value; playBtn.click(); playBtn.click(); log(before===rateEl.value,'暂停/播放后滑块保持不变'); },1000);
setTimeout(()=>{ log(usedComposerLastFrame || !useComposer, '渲染路径：合成链或已安全回退'); }, 1500);
let prevTicks=0; setTimeout(()=>{ const ok = _test.ticks > prevTicks; log(ok,'帧计数持续更新'); prevTicks=_test.ticks; }, 2500);
}); // DOMContentLoaded
</script>
</body>
</html>